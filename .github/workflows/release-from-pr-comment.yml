name: release-from-pr-comment

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
  attestations: write

concurrency:
  group: release-pr-${{ github.event.issue.number }}
  cancel-in-progress: false

jobs:
  resolve:
    name: Resolve PR metadata
    if: >
      github.event.issue.pull_request &&
      (contains(github.event.comment.body, '!release patch') ||
       contains(github.event.comment.body, '!release minor') ||
       contains(github.event.comment.body, '!release major')) &&
      (github.event.comment.author_association == 'OWNER' ||
       github.event.comment.author_association == 'MEMBER' ||
       github.event.comment.author_association == 'COLLABORATOR')
    runs-on: ubuntu-latest
    outputs:
      release_type: ${{ steps.pr.outputs.release_type }}
      pr_number: ${{ steps.pr.outputs.pr_number }}
      head_repo: ${{ steps.pr.outputs.head_repo }}
      head_ref: ${{ steps.pr.outputs.head_ref }}
      head_sha: ${{ steps.pr.outputs.head_sha }}
      base_ref: ${{ steps.pr.outputs.base_ref }}
      base_sha: ${{ steps.pr.outputs.base_sha }}
      html_url: ${{ steps.pr.outputs.html_url }}
    steps:
      - name: Resolve PR metadata
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.comment.body || "";
            const match = body.match(/(^|\s)!release\s+(major|minor|patch)\b/i);
            if (!match) core.setFailed("No valid !release command found.");
            const releaseType = match[2].toLowerCase();

            const prNumber = context.payload.issue.number;
            const { owner, repo } = context.repo;
            const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });

            core.setOutput("release_type", releaseType);
            core.setOutput("pr_number", String(prNumber));
            core.setOutput("head_repo", pr.data.head.repo.full_name);
            core.setOutput("head_ref", pr.data.head.ref);
            core.setOutput("head_sha", pr.data.head.sha);
            core.setOutput("base_ref", pr.data.base.ref);
            core.setOutput("base_sha", pr.data.base.sha);
            core.setOutput("html_url", pr.data.html_url);

      - name: Guard - only same-repo PR branches
        if: steps.pr.outputs.head_repo != github.repository
        run: |
          echo "Refusing to run release workflow for fork PR: ${{ steps.pr.outputs.head_repo }}"
          exit 1

  build:
    name: Build distribution
    needs: resolve
    runs-on: ubuntu-latest
    outputs:
      old_version: ${{ steps.bump.outputs.old_version }}
      new_version: ${{ steps.bump.outputs.new_version }}
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve.outputs.head_ref }}
          fetch-depth: 0

      - name: Fetch base branch
        run: |
          git fetch origin ${{ needs.resolve.outputs.base_ref }} --no-tags

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: pip

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install -e ".[dev]"
          python -m pip install build

      - name: Run tests
        run: |
          python -m pytest -q

      - name: Bump version + update changelog
        id: bump
        env:
          RELEASE_TYPE: ${{ needs.resolve.outputs.release_type }}
          BASE_REF: ${{ needs.resolve.outputs.base_ref }}
        run: |
          python - <<'PY'
          import os
          import re
          import subprocess
          from datetime import date

          release_type = os.environ["RELEASE_TYPE"]
          base_ref = os.environ["BASE_REF"]

          def sh(*args: str) -> str:
            return subprocess.check_output(args, text=True).strip()

          def bump(version: str, kind: str) -> str:
            m = re.fullmatch(r"(\d+)\.(\d+)\.(\d+)", version)
            if not m:
              raise SystemExit(f"Unsupported version format: {version}")
            major, minor, patch = map(int, m.groups())
            if kind == "major":
              return f"{major+1}.0.0"
            if kind == "minor":
              return f"{major}.{minor+1}.0"
            if kind == "patch":
              return f"{major}.{minor}.{patch+1}"
            raise SystemExit(f"Unknown release type: {kind}")

          pyproject_path = "pyproject.toml"
          text = open(pyproject_path, "r", encoding="utf-8").read().splitlines(True)

          in_project = False
          old_version = None
          for i, line in enumerate(text):
            if line.strip() == "[project]":
              in_project = True
              continue
            if in_project and line.startswith("[") and line.strip().endswith("]"):
              in_project = False
            if in_project:
              m = re.match(r'^\s*version\s*=\s*"([^"]+)"\s*$', line)
              if m:
                old_version = m.group(1)
                new_version = bump(old_version, release_type)
                text[i] = re.sub(r'"[^"]+"', f'"{new_version}"', line, count=1)
                break

          if not old_version:
            raise SystemExit("Could not find [project].version in pyproject.toml")

          open(pyproject_path, "w", encoding="utf-8").write("".join(text))

          # Build changelog entries from PR commit range (merge-base..HEAD) to avoid
          # picking up unrelated base branch commits if the PR branch was rebased/merged.
          merge_base = sh("git", "merge-base", "HEAD", f"origin/{base_ref}")
          log = sh("git", "log", "--no-merges", "--pretty=%s", f"{merge_base}..HEAD")
          commits = [l.strip() for l in log.splitlines() if l.strip()]
          if not commits:
            commits = ["(no commits found in PR range)"]

          section = []
          section.append(f"## {new_version} - {date.today().isoformat()}\n")
          section.append("\n")
          for subj in commits:
            section.append(f"- {subj}\n")
          section.append("\n")
          section_text = "".join(section)

          changelog_path = "CHANGELOG.md"
          try:
            existing = open(changelog_path, "r", encoding="utf-8").read()
          except FileNotFoundError:
            existing = "# Changelog\n\n"

          if existing.startswith("# Changelog"):
            head = "# Changelog\n"
            rest = existing[len(head):]
            # Ensure a blank line after header.
            rest = rest.lstrip("\n")
            new_text = head + "\n" + section_text + rest
          else:
            new_text = "# Changelog\n\n" + section_text + existing.lstrip()

          open(changelog_path, "w", encoding="utf-8").write(new_text)

          sh("git", "add", pyproject_path, changelog_path)

          # Output new version for later steps.
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
            f.write(f"old_version={old_version}\n")
            f.write(f"new_version={new_version}\n")
          PY

      - name: Commit version/changelog back to PR
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "chore(release): v${{ steps.bump.outputs.new_version }}" || exit 0
          git push origin HEAD:${{ needs.resolve.outputs.head_ref }}

      - name: Build package
        run: |
          python -m build

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

  publish:
    name: Publish to PyPI
    needs: [resolve, build]
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/roamresearch-client-py
    steps:
      - name: Download distribution artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

      - name: Publish to PyPI (Trusted Publishing)
        uses: pypa/gh-action-pypi-publish@release/v1

  release:
    name: Create GitHub Release
    needs: [resolve, build, publish]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve.outputs.head_ref }}
          fetch-depth: 0

      - name: Pull latest changes
        run: |
          git pull origin ${{ needs.resolve.outputs.head_ref }}

      - name: Create and push tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "v${{ needs.build.outputs.new_version }}" -m "Release v${{ needs.build.outputs.new_version }}"
          git push origin "v${{ needs.build.outputs.new_version }}"

      - name: Download distribution artifacts
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.build.outputs.new_version }}
          name: v${{ needs.build.outputs.new_version }}
          generate_release_notes: true
          files: dist/*

  notify:
    name: Comment on PR
    needs: [resolve, build, publish, release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Comment result on PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number("${{ needs.resolve.outputs.pr_number }}");
            const releaseType = "${{ needs.resolve.outputs.release_type }}";
            const newVersion = "${{ needs.build.outputs.new_version }}";
            const publishStatus = "${{ needs.publish.result }}";
            const releaseStatus = "${{ needs.release.result }}";

            let body;
            if (publishStatus === "success" && releaseStatus === "success") {
              body = `üöÄ Released \`v${newVersion}\` successfully!\n\n` +
                     `- PyPI: https://pypi.org/project/roamresearch-client-py/${newVersion}/\n` +
                     `- GitHub Release: https://github.com/${{ github.repository }}/releases/tag/v${newVersion}\n\n` +
                     `Trigger: \`!release ${releaseType}\``;
            } else if (publishStatus === "success") {
              body = `üì¶ Published \`v${newVersion}\` to PyPI, but GitHub Release creation failed.\n\n` +
                     `Trigger: \`!release ${releaseType}\`. Check Actions logs for details.`;
            } else {
              body = `‚ùå Release workflow failed (trigger: \`!release ${releaseType}\`). Check Actions logs.`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body,
            });
